package com.SE459.Portal.Service;

import com.SE459.Portal.Configuration.OneTimeScheduler;
import com.SE459.Portal.Configuration.RepeatedScheduler;
import com.SE459.Portal.Dao.*;
import com.SE459.Portal.Entity.*;
import com.SE459.SensorsCollection.MapManipulator;
import com.SE459.SensorsCollection.SensorsCollection;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.logging.Logger;

@Service
public class DeviceService {
	ArrayList<String> direction = new ArrayList<String>();

	@Autowired
	DeviceDao deviceDao;

	@Autowired
	AccountDao accountDao;

	@Autowired
	CleanerDao cleanDao;

	@Autowired
	DirtDetectorDao dirtDetectorDao;

	@Autowired
	NavigatorDao navigatorDao;

	@Autowired
	ScheduleDao schedulerDao;

	@Autowired
	PowerManagerDao powerManagerDao;

	@Autowired
	LogDao logDao;

	SensorsCollection sensorsCollection;
	private int accountId;

	public DeviceService() {
		sensorsCollection = new SensorsCollection();
	}

	private final Logger logger = Logger.getLogger(this.getClass().getName());

	public Device createNewDevice() {
		Device newDevice = new Device(new Cleaner(), new DirtDetector(), new Navigator(), new Scheduler(), new PowerManager());

		return newDevice;
	}

	public ArrayList<String> oneButtonClean(String email) throws InterruptedException {

		SensorsCollection sensorsCollection = new SensorsCollection();
		sensorsCollection.generateBasicMap(1);

		MapManipulator m = new MapManipulator(sensorsCollection.getMapArch());

		//close the door in the Guest Bedroom A
		List<String> cmd = new LinkedList<>();

		// Demonstration of closing a door at a given node
		cmd.add("6-35-close");
		m.openOrCloseDoor(cmd);

		//generate the changed map and the changed json file will cover the previous one that was generated by s.generateBasicMap(1)
		sensorsCollection.runFinalMap();
		return sensorsCollection.clean();
	}

	public int getBattery(String email) {
		int currentBattery = 0;
		Device device = accountDao.findAccountByEmail(email).getDevice();
		if(device.getPowerManager()!=null) {

			currentBattery=device.getPowerManager().getBatteryLife();
		}
		return currentBattery;
	}

	public boolean saveDevice(Device d) {
		try {
			cleanDao.save(d.getCleaner());
			dirtDetectorDao.save(d.getDirtDetector());
			navigatorDao.save(d.getNavigator());
			schedulerDao.save(d.getScheduler());
			powerManagerDao.save(d.getPowerManager());
			this.deviceDao.save(d);
			return true;
		}
		catch (Exception e) {
			logger.throwing(this.getClass().getName(), "saveDevice", e);
			return false;
		}
	}

	public boolean deleteDevice(Device d) {
		try {
			logger.info(getClass().getName() + ": deleteDevice");
			deviceDao.delete(d);

			return true;
		}
		catch(Exception e) {
			logger.throwing(getClass().getName(), "deleteDevice", e);
			return false;
		}
	}

	public Runnable OneTimeRunner(int accountId, String scheduleString) {

		return new Runnable() {
			@Override
			public void run() {
				logger.info("One Time Clean Task: " + scheduleString);

				// Create a Log with the timestamp and what type of scheduled cleaning is being done.
				DateTimeFormatter dateTimeFormat = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");
				String currentDateTime = LocalDateTime.now().format(dateTimeFormat);
				Log newTimeStampLog = new Log();
				newTimeStampLog.setLog("[" + currentDateTime + "]: One-Time Schedule Cleaning Task Activating.");
				newTimeStampLog.setAccountId(accountId);
				logDao.save(newTimeStampLog);

				sensorsCollection.generateBasicMap(1);
				MapManipulator m = new MapManipulator(sensorsCollection.getMapArch());

				//close the door in the Guest Bedroom A
				List<String> cmd = new LinkedList<>();
				cmd.add("6-35-close");
				m.openOrCloseDoor(cmd);

				//generate the changed map and the changed json file will cover the previous one that was generated by s.generateBasicMap(1)
				sensorsCollection.runFinalMap();
				ArrayList<String> logs = sensorsCollection.clean();

				// Save the Logs to the dao under the appropriate accountId
				for (String cleanLog : logs) {
					Log newLog = new Log();
					newLog.setLog(cleanLog);
					newLog.setAccountId(accountId);
					logDao.save(newLog);
				}

				OneTimeScheduler.getInstance().stopAll();
			}
		};
	}

	public Runnable RepeatedRunner(int accountId, String scheduleString) {

		return new Runnable() {
			@Override
			public void run() {
				logger.info("Repeated Clean Task: " + scheduleString);

				// Create a Log with the timestamp and what type of scheduled cleaning is being done.
				DateTimeFormatter dateTimeFormat = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");
				String currentDateTime = LocalDateTime.now().format(dateTimeFormat);
				Log newTimeStampLog = new Log();
				newTimeStampLog.setLog("[" + currentDateTime + "]: Repeated Schedule Cleaning Task Activating.");
				newTimeStampLog.setAccountId(accountId);
				logDao.save(newTimeStampLog);

				sensorsCollection.generateBasicMap(1);
				MapManipulator m = new MapManipulator(sensorsCollection.getMapArch());

				//close the door in the Guest Bedroom A
				List<String> cmd = new LinkedList<>();
				cmd.add("6-35-close");
				m.openOrCloseDoor(cmd);

				//generate the changed map and the changed json file will cover the previous one that was generated by s.generateBasicMap(1)
				sensorsCollection.runFinalMap();
				ArrayList<String> logs = sensorsCollection.clean();

				// Save the Logs to the dao under the appropriate accountId
				for (String cleanLog : logs) {
					Log newLog = new Log();
					newLog.setLog(cleanLog);
					newLog.setAccountId(accountId);
					logDao.save(newLog);
				}
			}
		};
	}
}